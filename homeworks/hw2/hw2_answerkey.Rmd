```{r message=FALSE}
# Notes for formatting:
# include = FALSE prevents code and results from appearing in the finished file. R Markdown still runs the code in the chunk, and the results can be used by other chunks.
# echo = FALSE prevents code, but not the results from appearing in the finished file. This is a useful way to embed figures.
# message = FALSE prevents messages that are generated by code from appearing in the finished file.
# warning = FALSEprevents warnings that are generated by code from appearing in the finished.
library(data.table)
library(readr)
library(readxl)
library(stargazer)
library(tidyverse)
```

---
title: "Empirical Exercise 2 Answer Key"
author: Eugene Tan
output: html_notebook
---

This problem set is due on October 26. I strongly recommend to start working on the homework early. You can work in pairs and submit a common solution. Please submit the homework as an R markdown file (if there are data files, they put all the files in a zip file). The code must run without errors. To make this easier, set the working directory at the beginning so it can be easily changed by someone else running the code.

For this exercise you will use a dataset collected by S&P Global. Choose one of the datasets available, which have data for either 2009 or 2018 for one of the following ISOs: MISO, PJM, ERCOT, or New England ISO. The goal of the exercise is to build the supply curve for a wholesale electricity market and to analyze how costs determine the composition of fuels and emissions. We will also use the exercise to see how things would change with a carbon tax.

#### Select the following variables from your dataset: 
* Plant Unit key
* Primary fuel type
* Generation technology
* Summer capacity MW
* Variable O&M cost per MWh (this is the variable cost)
* Total fuel cost per MWh (this is part of the variable cost) 
* Emission allowances costs (this is part of the variable cost) 
* Fixed O&M cost
* Heat rate btu/ kwh
* Heat input (MMBTU)
* Net generation MWh
* Capacity factor
* NOX Emissions Rate (lbs/MMBtu)
* SO2 Emissions Rate (lbs/MMBtu)
* CO2 Emissions Rate (lbs/MMBtu)

```{r echo = TRUE, warning = FALSE}
ercot2018 <- fread("data/ercot2018.csv")
ercot2009 <- fread("data/ERCOT_2009.csv")
ne2009 <- read_excel("data/ISO_NE_2009.xls", 
         col_types = c("text", "numeric", "numeric", 
         "text", "text", "text", "text", "numeric", 
         "numeric", "numeric", "numeric", 
         "numeric", "numeric", "numeric", 
         "numeric", "numeric", "numeric", 
         "numeric", "numeric", "numeric", 
         "numeric", "numeric", "numeric", 
         "numeric", "text", "text", "text", 
         "text", "text", "text", "text", "text", 
         "text", "text"))
ne2009 <- as.data.table(ne2009)
miso2018 <- fread("data/MISO2018.csv")
miso2018[,`Operating Status` := "Operating"]
ne2018 <- fread("data/NEISO_2018.csv")
ny2018 <- fread("data/NYISO_2018.csv") 
pjm2009 <- fread("data/PJM2009.csv", skip = 31)

# Get all the data in one list and name it
alldata <- list(ercot2018, ercot2009,ne2009,miso2018,ne2018,ny2018, pjm2009)
names(alldata) <- c("ercot2018", "ercot2009","ne2009","miso2018","ne2018","ny2018", "pjm2009")

# Get a unique list of all the column names
oldcols <- unique(unlist(sapply(alldata, names)))

# Map each of these to the variable name I want
newcols <- c('name','pkey','pukey','unitno','fueltype','tech','operating','capacity','capacity_adj','capacity_cum','vcost_om', 'vcost_fuel','vcost_om2','vcost_om3','vcost_emissions','fcost','tcost_om','heat_rate','heat_input','net_generation','cap_factor','nox','sox','co2','cogen','gscfuelsrc','gscnonfuelsrc','gscallowsrc','gscheatratesrc', 'gscheatinputsrc','gscgensrc','nox_emratesrc','so2_emratesrc','co2_emratesrc','name')

# Print to see that these match up.
names(newcols) <- oldcols
newcols

# Now loop through all the dts and set the new names and only choose the columns we want. 
format <- function (dt){
  # Set the new names for each column
  setnames(dt,oldcols, newcols, skip_absent = T)
  return(dt)
}

# Apply the above fucntion
alldata <- lapply(alldata, format)
```

### Part 1
Start by cleaning and understanding your data. For this, do the following:
#### What does each variable represent?
Just check understanding here: 

* Plant Unit key is the plant unit key.  In each plant, there may be multiple generators with different marginal costs. So each generator or unit has its own unique row in the dataset
* Primary fuel type - form of primary energy, one of "Solar", "Other Fuel", "Water", "Coal","Uranium","Natural Gas","Biomass","Petroleum Products","".
* Generation Technology - form of generator, e.g. Combustion Turbine, Combined Cycle, Hydro, Nuclear, Pumped Storage, Internal Combustion, Steam Turbine, Other, Solar, Wind.
* Summer capacity MW - capacity measured during summer. 
* Rest should be self-explanatory

#### Assign convenient yet meaningful names to each variable in the dataset.
```{r}
# Get the list of columns we want to select
wantcols <- c("pukey",'fueltype',"tech","capacity","vcost_om","vcost_fuel","vcost_emissions","fcost","heat_rate","heat_input","net_generation","cap_factor","nox","sox","co2","operating")

selec <- function (dt){
  # Select only the columns we want
  dt <- dt[,..wantcols]
  return(dt)
}

alldata <- lapply(alldata, selec)

# Print the top couple rows of each to see that it worked. 
lapply(alldata, dim) # Check there are 15 columns
```

#### What is the class of each variable? Make sure to convert them to the proper class before doing this. For example, if net generation is a character, make it numeric.
```{r}
# ANSWER KEY ONLY: I'll join all the data to be one data type in order not use loops 
# all the time for readability, and filter at the end to make it work for each graph. 
dt <- rbindlist(alldata, use.names = TRUE, idcol = 'isoyear')
# Capture the iso (as many characters as you like from a-z at the beginning)
dt[,iso:=str_match(isoyear,"^[a-z]*")] 
# Capture the year (4 digits from 0-9)
dt[,year:=as.integer(str_match(isoyear,"[0-9]{4}$"))] 

# Select the ones that I want to change the type of using a regular expression
convert_cols <- names(dt)[grepl('cost|heat|gen|cap',names(dt))]

# Some data cleaning needed before changing to numeric. 
# gsub isn't vectorized, so can't do this in data.table. 
for (col in convert_cols){
  # This is needed for all except ne2009
  # There are some commas that separate numbers that result in nas e.g. 100,000
  dt[[col]] <- gsub(",","",dt[[col]]) 
  # For pjm 2009 only because 0s are entered as "(0.00)"
  dt[[col]] <- gsub("\\(","",dt[[col]])
  dt[[col]] <- gsub("\\)","",dt[[col]])
}

# error checking why 
error <- dt[,as.numeric(vcost_emissions)]
#dt[is.na(error)]

# After the loop of checking that I'm not deleting data
dt<-dt[!is.na(error)]

# Convert the columns to the right datatype. 
dt[, (convert_cols) := lapply(.SD, as.numeric),.SDcols = convert_cols]
# Check it worked
str(dt)

# I am only going to use operating plants
dt <- dt[operating == 'Operating']
```

#### Describe each variable: what values does it take? Do you have any concerns about some variable (extreme values, missing values)?

You might be concerned about capacity factor being over 100%.  Because this is calculated off the summer capacity, this is actually okay - see this link from [UCS](https://www.ucsusa.org/resources/water-power-plant-cooling). The big one is heat_rate, which is the energy input over energy output.  

```{r}

# Extreme values:

# Heat rate - the generator shouldn't be able to produce more secondary than primary energy. 
dt[,energy_efficiency := 3412.14/heat_rate] # convert btu input/kwh output  to kwh output /kwh input
# Potentially Problematic generators by dataset
dt[energy_efficiency>1, .N, by =.(fueltype,isoyear)]  # 47 total problematic ones across all datasets
# You can choose to drop these or not
# dt<-dt[energy_efficiency<1] 
summary(dt[,energy_efficiency])

# Capacity factor should be <100
summary(dt[,cap_factor])
dt[cap_factor>100] #56 potentially problematic ones across all datasets
dt[cap_factor>100, .N, by =.(isoyear,fueltype)] 

# Missing values - can't say anything here really.
# Anything with fuel type missing is just an empty row that was imported by accident.
dt<-dt[!fueltype == ""]
summary(dt)
dt[is.na(net_generation), .N, by = isoyear]
dt[is.na(net_generation), .N, by = fueltype]
dt[is.na(net_generation), .N, by = tech]
```

### Part 2
Now let’s look at the importance of each fuel in this market.
#### a
What is the fuel composition of this market according to capacity (i.e. how
much capacity for each fuel)? Show it in a pie chart.
```{r}
# data for the grap
ggplot(dt[,.(capacity = sum(capacity, na.rm=T)), by = c("isoyear", "fueltype")], aes(x = "",y = capacity, fill = fueltype)) + 
    geom_bar(position = 'fill', stat="identity", width=1) +
    coord_polar("y", start=0)+
    ggtitle('Capacity Fuel composition by market') + 
    # geom_text(aes(x = 1.3, y = midpoint, label = labels)) +
    facet_wrap(~isoyear)+
    theme_void()
```
#### Part b
(b) What is the fuel composition of this market in terms of net generation?
Show it in a pie chart.

```{r}
ggplot(dt[,.(net_generation = sum(net_generation, na.rm=T)), by = c("isoyear", "fueltype")], aes(x = "",y = net_generation, fill = fueltype)) + 
    geom_bar(position = 'fill', stat="identity", width=1) +
    coord_polar("y", start=0)+
    ggtitle('Net Generation fuel composition by market') + 
    # geom_text(aes(x = 1.3, y = midpoint, label = labels)) +
    facet_wrap(~isoyear)+
    theme_void()

```


#### Why are they different or similar?

Generally speaking:
* Capacity differs from net generation because more expensive plants should generate less than their theoretical max capacity, whereas cheap plants shouold have a high capacity factor. 
* Intermittency is also a reason why they are different - intermittency means that power plants can't produce at full capacity all the time, so net generation/total theoretical generation should be less than a plant that isn't intermittent, all other factors equal. 
* Dispatchability or lack-thereof - if a power plant is dispatchable, it is more likely to be used to turn on and off with wild short-term swings in electric power demand, but this has to be put in the context of the distribution of power plants available in that ISO.


#### How much does each fuel contribute to NOx, SO2, and CO2 emissions? Choose an appropriate plot type to answer this.

How much does each fuel contribute is a question about total emissions, not average emissions, so you should take the emissions rate, multiply by net generation, and that's the actual total emissions for that ISO. Then, you could interpret this in two ways - either the contribution is total emissions, in which case a graph for each is fine. Or you could interpret the question as being what is the difference in the composition between NOx, SO2, and CO2 given the generation of your iso - which was harder, more involved, but much more informative. 

```{r}
# Set the groupby key
setkey(dt, isoyear, fueltype) # Students should take out isoyear

# These plot general numbers for each dataset
# Emissions by dataset - fueltype
ggplot(dt[,.(emissions = sum(heat_input*co2, na.rm=T)), by = key(dt)],aes(x = factor(isoyear), y= emissions, fill = factor(fueltype))) + 
  geom_bar(stat = 'identity', position = 'dodge') + 
  scale_y_continuous(name = "CO2 Emissions (lbs)") + 
  scale_x_discrete(name = "ISO and year") + 
  scale_fill_discrete(name = "Fuel Type")

# Emissions by dataset - fueltype
ggplot(dt[,.(emissions = sum(heat_input*nox, na.rm=T)), by = key(dt)],aes(x = factor(isoyear), y= emissions, fill = factor(fueltype))) + 
  geom_bar(stat = 'identity', position = 'dodge') + 
  scale_y_continuous(name = "NO2 Emissions (lbs)") + 
  scale_x_discrete(name = "ISO and year") + 
  scale_fill_discrete(name = "Fuel Type")

# Emissions by dataset - fueltype
ggplot(dt[,.(emissions = sum(heat_input*sox, na.rm=T)), by = key(dt)],aes(x = factor(isoyear), y= emissions, fill = factor(fueltype))) + 
  geom_bar(stat = 'identity', position = 'dodge') + 
  scale_y_continuous(name = "SOx Emissions (lbs)") + 
  scale_x_discrete(name = "ISO and year") + 
  scale_fill_discrete(name = "Fuel Type")

# These produce a CO2 graph for each dataset
for (name in names(alldata)){
  print(
    ggplot(dt[isoyear == name,.(emissions = sum(net_generation*co2, na.rm=T)), by = key(dt)],aes(x = factor(isoyear), y= emissions, fill = factor(fueltype))) + 
  geom_bar(stat = 'identity', position = 'dodge') +
  scale_y_continuous(name = "CO2 Emissions (lbs)") + 
  scale_x_discrete(name = "Fuel type") + 
  scale_fill_discrete(name = "Fuel Type") + 
  ggtitle(paste(name,"- Emissions by fuel type"))
  )
}

# Calculate the total emissions
dt[, tnox := nox*net_generation]
dt[, tsox := sox*net_generation]
dt[, tco2 := co2*net_generation]


# Create a table with emissions in columns, indexed by isoyear and fuel type.
emissions <- dt[,.(co2 = sum(tco2, na.rm = T),nox = sum(tnox, na.rm = T),sox= sum(tsox, na.rm = T)), by = c('isoyear','fueltype'),]
# Put the melted version, and I'm just using facetwrap to mkae one plot for each
ggplot(melt(emissions),aes(x = variable, y = value,fill = fueltype)) +
  geom_bar(position = 'fill',stat= 'identity') +
  facet_wrap(~isoyear)

```

```{r}
# Unnecessary data cleaning for the answer key. 
if (F){ # 
  # Assume that if there is na generation, that no electricity was produced
  dt[is.na(net_generation), net_generation:= 0] 
  
  # Checks which fuels have no emissions factors
  dt[, mean(co2, na.rm=T), by = key(dt)]
  dt[, mean(sox, na.rm=T), by = key(dt)]
  dt[, mean(nox, na.rm=T), by = key(dt)]
  
  # Assume that renewable fuels are zero-emissions if they do not already have a value assigned.
  renewables <- c('Solar','Uranium','Water','Wind')
  dt[is.na(co2) & fueltype %in% renewables, co2 := 0.]
  dt[is.na(nox) & fueltype %in% renewables, nox := 0.]
  dt[is.na(sox) & fueltype %in% renewables, sox := 0.]
  
  # This is a reasonable but potentially bad assumption if the distribution of emisssions factors is skewed/fat-tailed, but I will set the nas for other emissions factors to be the mean or max of the distribution
  dt[is.na(nox), nox := mean(nox, na.rm = T), by = c('fueltype','tech')]
  
  summary(dt)
}
```
### Question 3

Organize the data and plot the generation supply curve using a different color for each fuel (Check here for a reference about supply curves.). The idea is to have a plot in which each plant is a dot, its height is its variable cost and its x- coordinate is the capacity of the system at a cost equal or lower than the plant’s. For this, you have to order generators according to variable cost, and calculate the cumulative capacity of the system. Use geom point such that each plant is a dot, but do not connect the dots. Label the plot properly, add a title and a legend.

```{r}
# The vcost_fuel is a component o fthe the operating cost, we see here that it never goes above the x = y line. 
ggplot(dt, aes(x = vcost_om, y = vcost_fuel)) + 
  geom_point()
```


```{r}
# Order generators according to variable cost
setorder(dt, isoyear, vcost_om)

# calculate the cumulative capacity of the system
dt[, cum_capacity := cumsum(capacity), by = isoyear]

# Draw the supply curve for all ISOs.
ggplot(dt, aes(x = cum_capacity, y = vcost_om, color = isoyear)) + 
  geom_point() + 
  xlab("Cumulative Summer Capacity (MW)")+ 
  ylab("Variable Cost ($/MWh)")

scs <- list()
# Draw the supply curve by iso using a different color for each uel. 
for (name in names(alldata)){
  scs[[name]] <-ggplot(dt[isoyear == name], aes(x = cum_capacity, y = vcost_om, color = fueltype)) + 
    geom_point() + 
    xlab("Cumulative Summer Capacity (MW)")+ 
    ylab("Variable Cost ($/MWh)")+
    ggtitle(paste(name, "Supply Curve"))
}
scs
ggplot(dt, aes(x = cum_capacity, y = vcost_om, color = fueltype)) + 
    geom_point() + 
  facet_wrap(~isoyear, nrow= 2, ncol = 4)

```

### Question 4
In the supply curve, are fuels ordered by cost? What do you think is the role of cost in explaining the differences between the capacity and net generation shares of each fuel?

Fuels are ordered by variable cost, not total cost. The higher the variable cost is, the lower the capacity factor should be (this is net generation over total theoretical generation, which scales with capacity). ISOs create a merit order for each instant based on cost, subject to the constraint of dispatchability, and so cost should explain the differences up to that constraint.

### Question 5 
Now you will create three values that we will use to represent load. Let’s assume average load is 60% of capacity, winter peak is 80% of capacity, and summer peak is 90% of capacity.

#### Compute these three values of load.

```{r}

load <- dt[, .(total_capacity = max(cum_capacity)), by = isoyear]
# Data table v1
load[,`:=`(avg_load = .6*total_capacity, winter_peak = .8*total_capacity,summer_peak = .9*total_capacity)]
# Data table v2
load[,avg_load := .6*total_capacity]
load[,winter_peak := .8*total_capacity]
load[,summer_peak := .9*total_capacity]


```
#### Part b
Add the load values to the supply curve plot as vertical lines. Save this plot
as a pdf file using ggsave. 

```{r}
# Draw the supply curve by iso using a different color for each fuel. 
for (name in names(scs)){
  scs[[name]] <- scs[[name]] + 
    geom_vline(xintercept = load[isoyear ==name, avg_load])+
    geom_vline(xintercept = load[isoyear ==name, winter_peak])+
    geom_vline(xintercept = load[isoyear ==name, summer_peak])
  ggsave(paste("supplycurve", name, ".pdf", sep = ""), device = "pdf", width = 16, height = 9, units = "in")
}
scs
```

#### Part c

For each of these three load levels, find the price that would have cleared the market if price were equal to cost, i.e. find the point in the supply curve intersects the load curve (vertical line) in the plot.

```{r}
# Set up the merge
setkey(load, isoyear)
setkey(dt, isoyear)

# join the loads to the data table
dt <- merge(dt, load)

# Find the prices using merge iteratively (using reduce)
# Each of the lines subsets the cumulative capacity above average load and then finds the minimum price, doing so for each ISO-YEAR. 
dt_price <- Reduce(merge, list(
dt[cum_capacity > avg_load, .(p_avg_load = min(vcost_om)),isoyear], 
dt[cum_capacity > winter_peak, .(p_winter_peak = min(vcost_om)),isoyear],
dt[cum_capacity > summer_peak, .(p_summer_peak = min(vcost_om)),isoyear],
load
))

# This is a less clean method of getting the price using a for loop, shown only for average load:
breakeven <- list()
for (name in names(alldata)){
  # Get average load
  avg_load <- load[isoyear == name, avg_load]
  # Get the 1st one with higher than average load
  breakeven[[name]] <- dt[isoyear == name][dt[isoyear == name, (cum_capacity > avg_load)]][1]
}

breakeven
breakeven<- rbindlist(breakeven)
breakeven[, price := vcost_om]

dt_price
```

### Question 6
Suppose we want to know if the dispatch of power plants is efficient, i.e. if cheaper plants are dispatched first. Do cheaper power plants produce more? To check this, do the following:

#### Part a 

Run an OLS regression of net generation on cost. What cost is the most relevant here? Try total cost and variable cost and argue why/how results vary with the cost definition. Briefly discuss.

Running ols on variable and fixed cost
The coefficient on variable cost is negative, so generation decreases with higher cost. This makes sense if you consider the effect of cost on the merit order.  The coefficient on fixed cost is positive, which means that more expensive plants (per kW) generate more. Several reasons  - renewables have high fixed costs and they come first in the merit order, economies of scale means that cheaper fixed-cost plants are bigger and so generate more.  But an omitted variable is capacity - it is correlated with both variable and fixed costs and has a direct effect on net generation. 

Running OLS on total cost per year doesn't quite make sense when you have more disaggregated data and you're trying to figure out the mechanism, but the coefficient is positive in general. This is most probably the impact of capacity being an ommited variable.

I run everything using a fixed cost for the dataset that you use - your results will differ.

```{r}
# Calculate the total costs first,
# fcost is in units of $/kW-year, need to compare to $/year
# vcost is in units of $/MWh, multiply by generation (mwh/year) to get to $/year. 
dt[, tcost_om := vcost_om * net_generation + fcost *capacity * 1000]
dt[, tcost_fuel := vcost_fuel * net_generation+ fcost *capacity *1000 ]
dt[, tcost_emissions := vcost_emissions * net_generation+ fcost *capacity*1000]


# Naive regression, noting that vcost_fuel is collinear with vcost_om
model1 <- lm("net_generation ~ vcost_om  + fcost + isoyear", dt)
summary(model1)
# Answers depend on ISO.  
library(lfe)
library(plm)




# How to use the felm function:
# first part: formula without fixed effects
# second part: fixed effects
# third part: IV specification (write 0 if not using an IV)
# fourth part: level at which to cluster the standard errors
# This function allows to clustered standard errors at a level different from the fixed effects.
dt[, isoyear := as.factor(isoyear)]
#felm("net_generation ~ vcost_om  + fcost | isoyear", dt)

# Same using total variable costs as in the question rather than 
model2 <- lm("net_generation ~ tcost_om  + fcost + isoyear", dt)
summary(model2)
```

(b) Now control for capacity, how do results change?

Variable cost retains a negative coefficient, but its significance and magnitude goes down.  We can interpret the coefficient as follows - if a plant costs 1$/MWh more, how much more MWh (it is negative, so less) is it likely to have generated? When we control for capacity, the decrease in coefficient shows that the impact of cost is not as dramatic. The coefficients for total and fixed costs also decrease but stay on the same order of magnitude.  
```{r}
# Naive regression, noting that vcost_fuel is collinear with vcost_om
model4 <- lm("net_generation ~ vcost_om + fcost + capacity + isoyear", dt)
summary(model4)

# Same using total variable costs as in the question rather than 
model5 <- lm("net_generation ~ tcost_om  + fcost + capacity + isoyear", dt)
summary(model5)
```

(c) What else could you be missing that may lead to bias? Can you control for it? Add some control that you consider relevant and discuss how it changes the results.

We are looking at the effect of cost on generation, one thing we could be missing is the impact of intermittency and dispatchability. You could also control for fuel type if you interpret the coefficient as within-fuel impact of price on net_generation. I'll show one then the other. 

Interestingly, fixed cost LOSES its significance once you add dispatchability and intermittency or fueltype. Dispatchability and intermittency both have extremely negative coefficients, as you might expect since they consist of non-baseload plants and also the plants that can't physically produce all the time. 


```{r}
# Print these to see the combinations of technologies
#unique(dt[, tech])
unique(dt[,.(tech, fueltype)])

dispatchable_techs = c('Hydro','Steam Turbine','Combustion Turbine', 'Combined Cycle', 'Internal Combustion','Pumped Storage')
intermittent_techs = c('Solar','Wind')
# dt <- dt[!is.na(net_generation)]
dt[,dispatchable := 0]
dt[,intermittent := 0]
dt[tech %in% dispatchable_techs, dispatchable := 1]
dt[tech %in% intermittent_techs, intermittent := 1]


# Intermittency and dispatchability dummies
summary(lm("net_generation ~ vcost_om + fcost + intermittent+ dispatchable + isoyear", dt))
# Fueltype fixed effect
summary(lm("net_generation ~ vcost_om + fcost + fueltype + isoyear", dt))
# Technology fixed effect
summary(lm("net_generation ~ vcost_om + fcost + tech + isoyear", dt))
# Both fueltype and technology
summary(lm("net_generation ~ vcost_om + fcost + fueltype +  tech + isoyear", dt))
```

7. (Extra credit) Now you will calculate the profits that each generator would have made if the price had been the price you find assuming average load (the price on an average hour).

(a) First, calculate profits, which are given by (P − mc)Q. Use variable cost as marginal cost, quantity is net generation. Describe profits by fuel type. For this, create a table that includes minimum, percentile 25, mean, median, percentile 75, and max value for each fuel type (fuel types are rows).

```{r}

# Merge in the prices. 
# setkey(dt_price, isoyear)
dt <- merge(dt, dt_price[,.(isoyear, p_avg_load, p_winter_peak, p_summer_peak)], by = 'isoyear')

dt[, profits := (p_avg_load - vcost_om)*net_generation]

# Ge tthe profits grouping over isoyear and fueltype, (not filtering for na net_generation causes bugs)
#https://stackoverflow.com/questions/25928708/using-summary-function-inside-data-table
dt[!is.na(net_generation), as.list(summary(profits, na,rm)),.(isoyear, fueltype)]

```

#### Part b)
Now compute total profits considering fixed costs (P −mc)Q−F, and create the same table as above. Do firms cover their costs?

Many firms do not cover their costs. You should reference a percentile to say something like the median xyz firms cover their costs, the median xyz firms don't. 

Interestingly, across ISOs the median Uranium plants consistently cover their costs, and most renewable plants too. It is predominantly natural gas, biomass, and petroleum product fueled plants where the median plant in all ISOs don't cover their costs. 
```{r}
dt[,total_profits := profits - fcost*capacity*1000]
profits <- dt[!is.na(net_generation), as.list(summary(total_profits, na,rm)),.(isoyear, fueltype)]
setorder(profits, Median)
profits
```

8. (Extra credit) Now we will repeat the same exercise but with social cost instead of private cost.
(a) We will use $50 for the social cost of carbon, but write your code using it as a parameter such that you can easily change it (Define scc as a variable at the beginning, and use scc instead of the actual value in the code. ).

```{r}
scc <- 50
```

(b) Compute the social variable cost for each generation. First, combine heat rate, heat input, and CO2 emissions rate to obtain CO2 tons emitted per MWh. In the data we have the emission rates in lbs/MMBTU for CO2. We also have the heat input in MMBTU. Therefore, by multiplying both variables we can construct the emission in lbs. Then, multiplying this variable by a constant k = 0.00045359237 we can convert from lbs to tons. Finally, we know the generation in MWh. So, we can calculate the emissions in tons per MWh.
CO2 Emissions ratei (tons/MWH) =
Emission ratei (lbs/MMBTU) · Heat inputi (MMBTU) · k (ton/lbs)
Generationi (M W h)

```{r}
#dt[,tco2_mwh := co2 * 0.00045359237 * heat_input/net_generation] # CO2 is now tco2/MWh
# Alternatively you could do this
dt[,tco2_mwh := co2 * 0.00045359237 * heat_rate/1000] # heat rate is btu/kwh 
dt[is.na(tco2_mwh), tco2_mwh:=0]
dt[, external_cost_co2  := tco2_mwh*(scc)] # $/MWh since scc is $/tco2, and co2 is tco2/Mwh
dt[, social_cost := vcost_om + external_cost_co2]

```

(c) Plot the social cost supply curve and load. Find the price that would clear if load was equal to average load (call this P S ), and the corresponding quantity.
```{r}
# Check what the scatter plot looks like 
ggplot(dt) + geom_point(aes(x = social_cost, y = vcost_om))

# Note that the supply curve will change the order of plants in our supply curve. So we have to recalculate cumulative capacity. 

# Order by social cost
setorder(dt, social_cost)
# Cumulative capacity in the social cost order
dt[, cum_capacity_sc := cumsum(capacity), isoyear]

scscs <- list() # Social cost supply curves
for (name in names(alldata)){
  scscs[[name]] <-ggplot(dt[isoyear == name], aes(x = cum_capacity_sc, y = social_cost, color = fueltype)) + 
    geom_point() + 
    geom_point(aes(x = cum_capacity, y = vcost_om), alpha = 0.5, size = 0.5,shape = 0) + # I plot the private costs below it
    geom_vline(xintercept = load[isoyear == name, avg_load]) +
    xlab("Cumulative Summer Capacity (MW)")+ 
    ylab("Social Cost ($/MWh)")+
    ggtitle(paste(name, "Supply Curve"))
}
scscs

dt_price2 <- merge(dt_price,dt[cum_capacity_sc>avg_load, .(p_s = min(social_cost)), isoyear])
dt_price2[, .(isoyear, p_avg_load, p_s)]
dt <- merge(dt, dt_price2[,.(isoyear, p_s)], by = 'isoyear')
```


9. (Extra credit) Now we will compare total emissions in a world that dispatches plants according to private variable cost (as it is today), with a world in which plants are dispatched according to social cost (which would happen with a tax on carbon, for example).
(a) Calculate total emissions during an average hour assuming firms are dispatched according to social cost. For this, you have to follow these steps:
i. Create variable that indicates whether a plant operates or not in an average hour (it operates if its social cost is lower than or equal to PS).
ii. Create another variable with each plant’s emissions assuming they
produce at capacity (why capacity? Think of the supply curve).
iii. Then add up emissions for all plants that operate when the price is lower
than or equal to PS.

```{r}
# You can actually do this in one line
part9 <- dt[social_cost<p_s, .(co2ph_social = sum(tco2_mwh*capacity)), isoyear] # co2 is now tco2/mwh --> tco2/h

# Rx (as prescribed)
# i 
dt[, emits := 0]
dt[social_cost<p_s, emits := 1]
# ii 
dt[, emissions := tco2_mwh*capacity]
# iii (compares both methods)
merge(part9, dt[, .(co2ph_social = sum(emits*emissions, na.rm= T)), isoyear])
```
(b) Find total emissions for the case in which plants are dispatched according to private variable cost, not social cost, using the procedure above. Notice that now a plant operates if its variable cost is at or below the clearing price calculated in 5c.
```{r}
# Compare co2 emissions per hour under different regimes
part9 <- merge(part9, dt[p_avg_load > vcost_om , .(co2ph_private = sum(tco2_mwh*capacity)), isoyear])
part9
```


(c) How many tons could we save in an hour if the social cost of carbon were internalized? And in a day? And in a year? Comment about how the fuel shares of this particular market affect the results of this exercise.

Depends on the market. Fuel shares by market basically determine how the merit order changes with the CO2 tax.  Savings can be very large (e.g. ERCOT) or small (NEISO), depedning on how much fossil fuels that are marginal to thte tax. 
```{r}
part9[,co2_savings := co2ph_private-co2ph_social]
part9[,co2_savings_annual := co2_savings * 24 *365]
part9
```

(d) (Bonus) How does the above answer change with different values for the social cost of carbon?

There should be more CO2 savings for a higher SCC. The larger the tax, the more fossil fuel plants that will be marginal. 

(e) (Extra bonus) Can you write a function that helps you to compute this?

NY and NE ISO have weird non-monotonically increasing results

```{r}
scc
co2_savings <- function(scc, dt = dt){
  # Calculate the social cost at the new SCC
  dt[, social_cost := vcost_om + tco2_mwh*scc]
  # Then order power plants in order of social cot
  setorder(dt, social_cost)
  # Find cumulative capacity
  dt[, cum_capacity_sc := cumsum(capacity), isoyear]
  # Reset the data table
  dt[, p_s := NULL]
  # Calculate Price
  dt <- merge(dt, dt[cum_capacity_sc>avg_load, .(p_s = min(social_cost)), isoyear])
  # Calculate Emissions
  dcast(dt[social_cost<p_s, .(co2ph = sum(tco2_mwh*capacity, na.rm= T), scc = paste0('co2ph',scc)), isoyear],"isoyear ~ scc", value.var = "co2ph")
}

emissions <- Reduce(merge, lapply(0:20*5, co2_savings, dt = dt))
emissions

# Savings
savings <- emissions[, .(isoyear, co2ph0 - .SD), .SDcols = names(emissions)[2:length(names(emissions))]]
savings

```






